# ソフトウェアテスト

自動テストはまず実行時間で分類する。
単体とか統合とかはそれほど重要ではない。

先に When-Then を書いてから、Given を考える。

未知の問題を見つけて既知にするか、
既知の問題が再発していないことを確認するか。

プログラマーはとにかくテストが全ての基礎になる。
テストを考えて、実装したら確かめられないと実装したとは言えない。

テストすれば嘘はつけない。

機能 (Feature) + 観点 (Scenario) → テストケース

試験内容に問題があって失敗した場合は試験内容を修正して再試験する。

[テストを書くか書かないかの状況判断](https://speakerdeck.com/twada/deciding-whether-to-write-tests-dena-tech-talk)

[質とスピード（2020 秋 100 分拡大版）](https://speakerdeck.com/twada/quality-and-speed-2020-autumn-edition)

[優れたテスト容易性を実現するためのポイント](https://www.praha-inc.com/lab/posts/testability)

> テストは品質を「上げる」ものではなく、品質が「わかる」ようになるもの
>
> https://speakerdeck.com/twada/strategy-and-tactics-of-building-automated-testing-culture-into-organization-2019-summer-edition?slide=25

「テスト」は意味が広いので、「ソフトウェアテスト」や「システムテスト」のように、テストの対象で分類することが多い。

https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%86%E3%82%B9%E3%83%88

> テストがソフトウェアの使用方法に似ているほど、信頼性が高まります。
>
> https://testing-library.com/docs/guiding-principles/

失敗しないテストは何も検証できない。

早くから市場に投入する作戦は、ブレストをもっと大規模に行うのと同じ。
ブレストも結局はユーザーを想定して意見を出し合うが、それを本物のユーザーと一緒に行う。

テストができないコードは書くな。
逆に、テストできるならコピペでもいい。

実装してもバグが多い場合、仕様からテストを作って確認する能力が低い。
まずはテストを用意してやるとか、テストの実行方法や考え方を教えてやってレビューすると能力を伸ばせる。
テストが成果の質を決める最後の工程になるので、テストがちゃんと決まっていればそれを満たす質になるか、完成できずに捨てるか、どっちかになる。

# ソフトウェアテストの分類方法

-   実行方法（自動か、手動か）
-   仕様の欠陥を見つけるか、実装の欠陥を見つけるか
-   範囲（システムか、アプリケーションか、クラスか）
-   頻度 ≒ 実行時間（頻繁に実行できるかどうか）
-   対象の品質特性

