# Gremlin

Gremlin Traversal LanguageとGremlin Serverがある。
TinkerPopのグラフを走査する言語とそれを受け付けるサーバー。

単にGremlinというとグラフを走査する言語のこと。

走査というのは、グラフの各所にアクセスするための言語のこと。

TinkerPopで規定されているグラフにアクセスするための言語がGremlin。

Gremlin ServerはGremlinで書かれたテキストを受け取って、データを取得したり変更したりする。

エイリアスとラベルは別。
結果セットにはエイリアスをつけられる。
`as()`でエイリアスをつけて`select()`で絞り込んだり、`store()`で保存しておいて`cap()`で取り出したりすれば途中の結果セットにアクセスできる。

- `V()`: 頂点を取得する
- `E()`: 結合を取得する
- `has()`: 指定したプロパティを持つ頂点を絞り込む
- `hasLabel()`: 指定したラベルを持つ頂点を絞り込む
- `in()`: 入力方向の頂点を取得する
- `out()`: 出力方向の頂点を取得する
- `both()`: 両方向の頂点を取得する
- `as()`: 取得した頂点にエイリアスをつける
- `select()`: 指定したエイリアスを持つ頂点を絞り込む
- `store()`: 一時的なデータストアに保存する
- `cap()`: 一時的なデータストアから取得する
- `sideEffect()`: 現在の走査に影響しない別の操作を行う
- `addV()`: 頂点を追加する
- `drop()`: 頂点とそれに直接繋がる結合を削除する

`store()`と`cap()`のデータストアはコンテキストごとに作られる。
`g`が違うとまた別のデータストアになる。エイリアスみたいに一時的なもの。

`V(id)`は、指定したidの頂点か、空の結果セットを得る。
空の結果セットをさらに検索してもエラーにはならないが、一部の操作はエラーになるものがある。

`V(id).out()`のようにしたら、`V(id)`の結果セットは含まれず、`V(id)`の結果セットの出力方向の頂点が最新の結果セットになる。

`repeat()`で再起的に処理を繰り返せる。
`until()`や`times()`など、終了条件を明示する操作を書かなければ、循環参照で無限ループになる。注意して使おう。

`sideEffect()`の副作用は元の走査に影響しない。

`drop()`すると頂点と結合がまとめて削除される。トラバーサルに含まれない頂点は削除されない。

グラフを視覚化する場合は次のツールを使う。本当に表示するだけなら悪くはない。
https://github.com/prabushitha/gremlin-visualizer

https://tinkerpop.apache.org/docs/current/reference/#traversal

`id().is(id)`と`hasId(id)`は同じ。糖衣構文がある。

project()はby()と一緒に使うとさまざまな値を持ったmapを作れる。
project()にはキーを指定して、by()でそれぞれの値を設定する流れ。
project('id', 'out').by(id).by(out().count())みたいにmapを構築する。

新しい走査は常にV(), E(), addV(), addE(), inject()の5つのいずれかで始まる。これを使うと新しい走査になる。GraphTraversalを作る。
そこから5つのステップで結果を調整する。Gremlinの関数は基本的にmap, flatMap, filter, sideEffect, branchのいずれかを返す。
barrierはsideEffectの一種。

`next()`は反復子（イテレーター）を返す。反復子を使ってイテレーションする。
`iterate()`は反復を処理して、何も返さない。
