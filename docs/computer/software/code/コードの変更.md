システム変更の方法は、大きく二つに分けることができる。

1. 編集して祈る (Edit and Pray)
2. 保護して変更する (Cover and Modify)

テストのないレガシーコードを、保護して変更したいなら、次の手順で変更する。

1. 変更点を洗い出す
2. テストを書く場所を見つける
3. 依存関係を排除する
4. テストを書く

『レガシーコード改善ガイド』マイケル・C・フェザーズ

## 変更の種類

変更の内容による違い

- 変更 (追加 + 削除)
- 追加
- 削除

変更の対象による違い

- 仕様の変更
- 実装の変更

## 変更の安全度

左に行くほど変更に対して安全。

追加 > 削除 > 変更

## バージョン管理

メジャー x、マイナー y、パッチ z
x.y.zh

パッチ → 実装の変更
マイナー → 仕様の追加
メジャー → 仕様の削除（API に互換性がなくなる）

## 互換性

以下のような API があったとして、

DELETE /expense-categories/:id

パターン 1

GET /expense-categories/:id を追加 → 互換性がある
（クライアント側、 API を使用している側が壊れない）

パターン 2

DELETE /expense-categories/:id を削除 → 互換性がない
（クライアント側、API を使用している側が壊れる、そっちも変更が必要になる）

## 変更より、追加

できるだけ、「簡単」な「追加」を中心にコードを変更する。

```
// 消費税を計算する
function A() {
    xxxx
}
```

↓

```
// 消費税と法人税を計算する
function A() {
    xxxx
    yyyy // A を変更している
}
```

A を変更するのではなく、別のところに B を追加した方がいい。
変更より追加の方が安全にコードを変更できる。

```
A(); // 消費税を計算する
B(); // 法人税を計算する
```

「使っている側は壊れるか？」
「使っている側の修正が必要になるか？」
で判断する。

## 変更を分解する

変更は、追加 + 削除なので、コミットやブランチを分ける。

どうしても互換性がなくなる変更が必要な時は、バージョン 2 を作った方がいい。
バージョン 2 に移行 → バージョン 1 を廃止、の順で処理する。

バージョン 1 を使っている古いクライアントでも互換性を維持できる。

ただし、データベースとかが大きく変わってしまうとどうしようもない。
DB 設計は序盤にきっちり考えておいた方が、そのような致命的・破壊的な変更が少ない。

## 任意の入力は、追加しても互換性が崩れない

```
function A(a) {
    ...
}
```

↓ オプション引数 b を追加する

```
function A(a, b = "") {
    ...
}
```

呼び出し側が A(a) でも A(a, b) でも動作する。
互換性がある。

## 引数が減ると壊れる

```
function A(a, b) {
    ...
}
```

↓

```
function A(a) {
    ...
}
```

これでは互換性がなくなる。
A(a, b)の呼び出しが壊れる。

JavaScript とかだといける。勝手にオプション扱いになる。

## 必須の引数が増えると壊れる

必須の c が増えると、A(a), A(a, b)が呼び出せなくなる。
呼び出し側の変更が必要になる＝互換性がない。

データベーステーブルの必須項目が増えた時とかによくある。

## オプション引数に変更するのを、削除の代わりにする

代わりに、b をオプションにする。

```
function A(a, b = "") {
    ...
}
```

A(a, b) も A(a) もそのまま使える。

あるいは、A を変更せずに、A(a, "")で使う。

## 動作の変化

同じ入力で、同じ出力（結果）なら、動作は変わってない。

function A(a="", b="") {}
A(a) => a で絞り込んで、一覧を返す
A(a, b) => a, b で絞り込んで、一覧を返す

↓ 任意の引数 c を追加

function A(a="", b="", c="")
A(a) => a で絞り込んで、一覧を返す
A(a, b) => a, b で絞り込んで、一覧を返す
A(a, b, c) => a, b, c で絞り込んで、一覧を返す ← ここが追加されても、A(a), A(a, b)の動作は変わらないので、互換性がある

## 早すぎる共通化

今の時点では動作が同じでも、将来的に動作が分かれるものを共通化してしまっている、ということ。

将来的に、呼び出し側で別の API に分けないといけなくなる。→ 互換性がない変更が増える。

簡単な方針 → 3 回重複したら共通化する。（2 回でなく）

## まとめ

互換性のある変更と互換性のない変更を区別する。

呼び出し側に変更が必要かどうかで、互換性を判断できる。

できるだけ互換性のある変更だけで変更していく。

＋　回帰テストで、予想外の影響に気づく。
