# 整合性

全体の整合性を常に保つ整合性と、結果の整合性だけを保つ結果整合性がある。
とりあえず前者を全体整合性とでも呼んでおこう。

アプリケーションとしての整合性をデータベースで取ろうとすると余計な読み取りやロールバックが発生する。

データベース上は外部キーを使わずに、結果整合性を持たせる方法もある。
そもそもリレーショナルデータベースでないとその方法しかないこともある。

データベースは複数のアプリケーションやバッチから参照されるので、データベースで整合性を保証しておけば、それらすべてで一貫して保証される。
ただし、データベースで設定できるのはデータ的な部分だけなので、業務仕様的な部分は各モジュールで守らないといけない。

## 全体整合性

アプリケーションとデータベースの両方で整合性を保証する。

RDB では主に外部キーやユニークインデックスを用いる。
データベースで保証しにくい場合でも排他ロックで一件ずつ確認して保存する。

## 結果整合性

データベースではシステム的な整合性を保証しない。
つまり、局所的には正しくないデータが保存される可能性がある。

アプリケーション側は正しくないデータが取得できる場合も想定して、エラーを表示したり、正しくないデータでは状態遷移や操作を止めたりする。

例えば、予約システムで同じ時間に同じ席が埋まってしまうことがある。
データベースの整合性を保つには排他ロックで読み取りの段階からロックしないといけないが、高負荷に耐えられなくなってしまう。
代わりに、一旦は予約できるようにして、同じ時間に同じ席が埋まった場合は片方、あるいは両方を不正なデータとして扱う。
予約は入っている（あるいは予約の確定処理中、みたいな状態になる）が、そのままでは使えないので、何らかの対処が必要になる。
例えば、システム側で定期的に見回ってキャンセル扱いにするとか。
このような結果整合性を扱うためには、データの保存から利用までにある程度時間を空けるようにしないと結果を保証する前にそのデータを使わないといけない時間が来てしまうことがある。

アプリケーション的には結果整合性が保証されるまで結果が確定していない。
あとからキャンセルされる場合があるので、それを前提に通知や表示がないとユーザーにはわからない。
