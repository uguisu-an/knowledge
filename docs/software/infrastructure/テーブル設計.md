設定情報も適切にテーブルを分けよう。

外部キー制約も整合性のための機能なので、あえて整合性を取らないところには使わない。

handle や slug は変更される可能性があるので、id というよりは検索用の unique キーにする。

id は変更されない属性でなければならない。

データベースの設計は、データが制約の中で好き勝手に変更される前提で考える。
アプリケーションの制約をデータベース側に求めてはならない。

計算途中の情報も永続化しないとあとで不便なので、細かく記録する。

テーブル内のレコードがあまりにも多いようならテーブルは分けたほうが軽い。
少ないうちは気にしなくてもなんとかなる。

中間テーブルに関連をつけたい場合、だいたい関連のどっちかに持たせた方がいい。
例えば user と conversation の間にある conversation_user に read_message を持たせたいなら、user に持たせる。
user と conversation の間の関連が切れたら、残しておいてもいいし、明示的に削除してもいいし、どっちにしてもアプリケーションで制御する。

完全に UPDATE なしの INSERT/DELETE だけでデータを持つ方法もある。
UPDATE なしでデータを保持する場合、変更される部分はリストになる。
最新のレコードが最新のデータなので、最新のデータだけ取得して、変更があったらレコードを追加する。
削除はしなくてもいいが、バックアップして削除するとか、その場で削除する方法でも変わらない。

https://zenn.dev/rebi/articles/28c7f1fee5730a

「どう保持するか」の前に「どう処理するか」を考える。
テーブル設計はあくまでも「どう保持するか」で、先にドメインモデルやワークフローの設計が必要。

N:N の pivot にさらに子要素を追加したくなったら、別の pivot を用意すればいい。
例えば、チャットの会話と参加者の間に既読を追加したくなったら、
conversation_user { id, conversation_id, user_id }
conversation_user_read_messages { conversation_user_id, message_id }
ではなく、
conversation_user { conversation_id, user_id }
conversation_user_read_messages { conversation_id, user_id, message_id }
でいい。
pivot を参照するテーブルは避ける。

テーブルのリレーションは N:N をまず考えて、親子関係（あるいは所有する関係）になるときだけ 1:N にする。
「所有」以外の、単に関連のあるテーブルを 1:N にしてしまうと後から N:N になることがあるので対応が面倒になる。

テーブル設計はドメインモデルの設計とまた別だけど、ドメインモデルに合わせてテーブル設計するのが一番ずれが少ない。

既存のテーブルがあったら改めてドメインモデルを設計するか、テーブル設計に合わせて使うかは選択。

ユーザーから見て被ってると分かりづらくても、データベースで一意にする必要はない。アプリケーションで制限するだけで十分。
データベースの制約はあくまでもデータとしての制約。アプリケーションの制約に左右されるべきではない。
