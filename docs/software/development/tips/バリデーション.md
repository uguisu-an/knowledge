バリデーションの段階
エラーハンドリングの段階と同じかも。

1.  バリデーションしない

- プログラムは落ちたり落ちなかったりする。
- 不正な値をそのまま通してしまう。
- 原因の箇所よりも後ろでエラーやおかしな挙動が見られる。

2. 不正な値を拾って、その場で例外にする

- プログラムは落ちる。
- エラーの原因を特定しやすい。

3. ログを残して、汎用のメッセージを画面に表示する

- プログラムは落ちない。
- エラーの原因を特定しやすい。
- ユーザーにはなぜ止まったかわからない。

4. 詳細なメッセージを画面に表示して、操作を続けられる

- プログラムは落ちない。
- エラーの原因を特定しやすい。
- ユーザーの手で問題を解消できる。

クライアント側のバリデーションは、サーバー側のバリデーションが先にある。

サーバーのバリデーションもクライアントで区別して表示できないといけない。
単純に日本語でエラーを受け取ってそのままどこかに出してもいい。

どんなバリデーションがあるか。

画面上では、バリデーションというより、そもそも操作できないようにする。
例えば、行が3つまでしか作れないなら、作ってから警告するよりも、行を追加するボタンを無効にする。

サーバーとクライアントのバリデーションでは役割が違う。
クライアントのバリデーションはあくまでも早期にエラーを発見してユーザビリティを高めるものだ。

フロントエンドのバリデーションはサーバーのバリデーションのサブセット。
できるだけフロントエンドでもバリデーションした方が便利。早期リターンで、結果的にユーザーの手間が減る。
サーバーにアクセスしないと情報が取れないならサーバーに任せた方がいい。ただ、送信前に選択肢を絞るような対処はできる。
