# Cohesion

日本語では「凝集」の意。
IPA では「強度」とも呼ばれる。

強く凝集している方が良い。

単に「関連」の強い弱いといった方がわかりやすいかも。

やりすぎると構成要素が増えすぎて、全体として複雑になりすぎる。

関連しているものは近づける。
関連していないものは遠ざける。

凝集していると、変更する範囲が小さい。あるいは「決まる」と言うべきか。
一つの変更に対して、一箇所だけ変えるのが理想。

凝集していないと、ごっちゃになってるのを分離しないといけなかったり、逆に何箇所も同じ変更をしないといけなかったりする。

複合的な部分は、各部分を統合する責務だけに集中したい。

全体の処理（特にコントローラーのアクションやサービス）は、以下のようにきれいに分ける。

1. 元となるデータの取得や受信
2. データの変換やチェック
3. 変換したデータの保存や送信

取得の処理の中に変換や保存が混ざってはいけないし、それ以外も同様。
特に、変換の途中で取得したり保存したりする処理がよく見られるが、これは作りが悪い。
きれいに三つに分かれるようにする。

各部をさらに細かい関数に分けたりするのはその後。

オブジェクトの全てのメソッドで全てのプロパティを使わないと、凝集しているとは言えない。

凝集のためには関心や責務を分けないといけない。

処理や要素を切り出すことで、余計なスタイルや処理が切り出されて、それぞれの処理が読みやすくなる。
共通化とは別に、凝集のため、読みやすさのためにモジュールを分離するといい。

情報設計がイマイチだと、内部設計ではどうにもならないこともある。

凝集していないと、まず関連性があるかどうかを切り分けながら読まないといけない。
凝集度の低い設計は、喩えるなら３問のクイズをごちゃ混ぜにして１問にしているようなものだ。

一緒に使うことがないものをわざわざswitchで切り替えて呼び出す必要はない。
昔のphpみたいな。今はRESTで入り口が分かれているので、createとupdateは分ける。

## Example

以下のような一連の流れは凝集度が高い。

1. 作業 A (): 条件 X を満たす
2. 作業 B (条件 X): 条件 Y を満たす
3. 作業 C (条件 Y): 条件 Z を満たす

逆に、余計な作業が入っていると凝集度が低い。

1. 作業 A (): 条件 X を満たす
2. 作業 1
3. 作業 B (条件 X): 条件 Y を満たす, 条件 3 を満たす
4. 作業 C (条件 Y): 条件 Z を満たす
5. 作業 2

## Bad Smell

- 同じようで少し違う部品、マイナーチェンジがたくさんある

## Reference

https://speakerdeck.com/sonatard/coheision-coupling

https://fortee.jp/object-oriented-conference-2020/proposal/a826b6c6-167c-4c5c-bfc7-52bb8bc22ec1
