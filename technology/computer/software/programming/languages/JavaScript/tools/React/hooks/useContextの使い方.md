主にキャッシュのような使い方をする。

- 設定
- テーマ
- 認証・認可情報
- ダウンロードしたデータ

props を Context の value に変換するのは専用の Provider コンポーネントを用意するのが定石。

`createContext(defaultValue)` で定義した Context をインポートして、`useContext(Context)` で使う。

処理をまとめるだけならHooksでいい。
ApolloなんかはContextにキャッシュを持って、Hooksで制御する。

複数のコンポーネントを通して利用する情報を持つことが多いけど、本質的ではない。
Contextありきで複数コンポーネントに持たせようとするとグローバル変数と同じ。

データ自体は、Contextで持っていい。
変な処理が混ざっているとごちゃごちゃする。

ContextとHookをワンセットで作ってStore代わりにする`unstated-next`というライブラリもある。

Contextはグローバル変数なので、使いすぎると読みづらい。
正しく制御しなければならない。依存関係を一方通行にする。

コンテキストの適用範囲を決めるProviderと、データにアクセスするConsumerの役割がある。

Contextを使わずに、Propsにコンポーネントを渡して制御の方向を変えるアイデアもある。

ContextでできることはPropsでもできる。
基本はPropsで、何階層も上とやりとりする必要が多かったらContextを検討する。

`unstated-next`はContainerでContextとHooksのセットをまとめて作ってくれる。
StateをContextで共有するHooksが簡単に作れる。
ただ、便利すぎるので、Store以外の用途でも使えてしまう。

ダイアログの状態を保持するだけのコンテキストとか、便利だからといって別にキャッシュしなくていいものまでコンテキストにするのはやりすぎ。

コンポーネントのPropsにバケツリレーが必要なとき、Contextを使うのは限定的な場合だけ。
まずはコンポーネント自体をもっとフラットにして、処理が必要ならHooksに切り出して、もっと上の層で統合した方がいい。childrenでいいならchildrenを使う。
Propsのバケツリレーで解決するのはどうしても委譲したい時だけ。MUIのようなコンポーネントをラップするとか。Contextで解決するのはテーマやセクションレベルのような特殊な設定系だけ。

Context経由で状態を更新するのもいいけど、処理はHooksに置いて、Contextはあくまでもキャッシュとして扱った方がいい。

Contextには処理を持たせないのが基本。
`unstated-next`を使う場合でも、処理の本体は別のHooksに分けた方がいい。

まずはデータとrefetchだけで考えて、処理は他のフックや各コンポーネントに持たせたほうがいい。

複雑なコンポーネントではrefetchを子に渡したくなりがち。
まぁ、基本はイベントにonXxx関数を渡す方法だけど、あまりにも多かったらContextにしてしまったほうが楽ではある。

コンテキストは小さく分けられるようにして、Providerをまとめて登録できるようにコンポーネントにする。
小さく分けないと、必要以上に大きなコンテキストに依存しないといけなくなる。
小さく分けて、小さなコンテキストに依存したコンポーネントを作って、アプリケーションレベルのコンテキスト自体はまとめて全体に反映していい。
