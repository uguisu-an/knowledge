# 仕様と実装

仕様は、実装の「完了」の定義。

仕様が同じでも、実装を同じにする必要はない。

実装は仕様を満たさないといけない。

実装を知らないと使えないのは設計として失敗している。

実装ではなく、仕様に依存する。

テストが終わるまで「実装した」とは言えない。

テストされてないコードは実装されてないコードだ。

テストコードは実装を支援する。
先にテストを書けば、仕様を満たすまで失敗してくれる。

動作確認してない実装は完成してない。

実装して動作確認して、検証できる状態を標準的な「完成」とする。

実装してもまだ検証されてない。

実装は検証のための手段。

以下の順で作る。

1. 動くもの
2. 長く動くもの（メンテナンスしやすいもの）
3. 速く動くもの

受け入れ条件は「やること」に対して考えるので、「やらないこと」は出てこない。

仕様を詳しくしていく手順：

1. ユーザーストーリー
2. 受け入れ条件（フィーチャー＊シナリオ）
3. 受け入れテスト
4. 自動化された受け入れテスト

受け入れテストは実装の間に済ませる。
そもそも受け入れテストしていないものを「実装した」とは言わない。

テストも、実装ではなく、仕様に依存させる。

実装の都合でインタフェースを変えるべきではない。

部品を定義して、製品からは部品との境界だけを考えると複雑さを抑えられる。

仕様書には要求仕様だけを書かなければならない。
実装仕様に追従してしまうと、バグ（要求仕様と実装仕様の差分）かどうか判らなくなる。

定義されていない動作を例外として明示的に実装する。

例外を投げるのは、定義されていない動作を明示的に失敗させるため。

要求仕様と実装仕様

「要求仕様」は、受け入れテストによって定義できる。
「実装仕様」は、受け入れテストによって検証できる。

仕様が変われば、実装も変わる。

実装できない仕様は机上の空論だ。
SF は夢だが、すぐには実現できない。

実装仕様は、要求仕様を使った検査によって明らかになる。
ここで初めてバグが認識される。

「完成」の概念と関わりがある。
完成品の定義と完成品そのもの。要求仕様と実装仕様。

仕様と実装が一致しなければ、バグになる。
不具合やエラーとは別。

仕様と実装が一致しているかどうかは、検査されなければならない。
検査されるまで実装が終わったとは言えない。

新しい仕様を見つけるレビュー、新しい実装を見つけるリファクタリング、とも関わりがある。

より優れた実装方法の発見によって、より優れた仕様を採用できることがある。

製品を拡張していくと、仕様と検査項目は増えていく。全てにパスしないといけない。

実装しても価値があるとは限らない。
あくまでも完成しただけで、価値があるかどうか検証されなければならない。

完成しないと検証できない。

実装は、検証の手段でしかない。

実装のコストは高いが、ハードウェアよりはソフトウェアの方が低い。

仕様と実装における「テスト」は、仕様と実装が一致するのを確認するもの。
仕様とテストは一致していて、実装よりも前に決まっている。

対して、品質分野にも「テスト」がある。
こちらは新しい要求を見つけるためのもの。「レビュー」に近い。

素早く検証のイテレーションを回すためには、完成を近づけないといけない。
つまり、実装すべき仕様を削ったり、仮の実装＝モックで簡単な検証を先にやってみたり、実装に関わる作業を機械化したり。

モックは、少なくともデモ＝最小限のテストの範囲で仕様を満たす仮の実装。

仕様と実装が一致している限り、外から見ると、実装は隠れている。

仕様と実装は「製品」の言葉。
実装前の仕様はユーザーストーリーは「こういう製品を作ったら喜ぶだろう」という仮説だ。製品を実装して、検証したら証明できる。

実装作業はテストまで含むので、特定の設計でテストが面倒になるなら実装が簡単になるとは言わない。
